<?php
/**
 * @file
 * Code for the Stanford Feeds Helper module.
 */

 /**
 * Implements hook_feeds_processor_targets_alter()
 */
function stanford_feeds_helper_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_name) {
  // Load up.
  $loaded = &drupal_static(__FUNCTION__, FALSE);

  if (!$loaded) {
    $loaded = TRUE;
    $path = drupal_get_path('module', 'feeds') . '/mappers';
    $files = drupal_system_listing('/.*\.inc$/', $path, 'name', 0);
    foreach ($files as $file) {
      if (strstr($file->uri, '/mappers/')) {
        require_once (DRUPAL_ROOT . '/' . $file->uri);
      }
    }
  }

  foreach (field_info_instances($entity_type, $bundle_name) as $name => $instance) {
    $info = field_info_field($name);
    if ($info['type'] == 'field_collection') {

      $sub_type = 'field_collection_item';
      $new_targets = module_invoke_all('feeds_processor_targets', $sub_type, $info['field_name']);
      drupal_alter('feeds_processor_targets', $new_targets, $sub_type, $info['field_name']);

      foreach ($new_targets as $sub_name => $target) {
        $new_name = t($info['field_name']) . ':' . t($sub_name);
        $targets[$new_name] = $target;
        if (isset($target['name'])) {
          $targets[$new_name]['name'] = $instance['label'] . ':' . $target['name'];
        }

        // We override callback for now and retrieve original later.
        $targets[$new_name]['callback'] = 'stanford_feeds_helper_feeds_set_target';
      }
    }
  }
}

/**
 * Process Field Collection items
 */
function stanford_feeds_helper_feeds_set_target($source, &$entity, $target, $value) {
  $sub_targets = &drupal_static(__FUNCTION__, array());

  $args = explode(':', $target);
  $target = array_shift($args);
  $sub_target = implode(':', $args);

  $sub_type = 'field_collection_item';
  $new_targets = module_invoke_all('feeds_processor_targets', $sub_type, $target);
  drupal_alter('feeds_processor_targets', $new_targets, $sub_type, $target);

  // Now we retrieve old callbacks and keep then on a static cache.
  if (!isset($sub_targets[$target])) {
    $sub_targets[$target] = array();
    drupal_alter('feeds_processor_targets', $sub_targets[$target], $sub_type, $target);
  }

  $_sub_targets = $new_targets;

  $value = is_array($value) ? $value : array($value);
  $info = field_info_field($target);

  // Iterate over all values.
  $delta = 0;
  $field = isset($entity->$target) ? $entity->$target : array();
  try {
    foreach ($value as $v) {

      if (empty($v)) {
        // Avoid creation of empty field collections.
        continue;
      }

      if (isset($field['und'][$delta]['entity'])) {
        $field_collection_item = $field['und'][$delta]['entity'];
      }
      elseif (isset($field['und'][$delta]['value'])) {
        $field_collection_item = field_collection_item_load($field['und'][$delta]['value']);
      }

      if (empty($field_collection_item)) {
        $field_collection_item = entity_create('field_collection_item', array('field_name' => $target));
        $field_collection_item->setHostEntity($entity->feeds_item->entity_type, $entity);
      }

      $sub_mapping = array();
      $config = $source->importer()->getConfig();
      if (!empty($config['processor']['config']['mappings'])) {
        foreach ($config['processor']['config']['mappings'] as $mapping) {
          if ($mapping['target'] == $target . ':' . $sub_target) {
            $sub_mapping = $mapping;
            $sub_mapping['target'] = $sub_target;
            // Needs language or feeds mappers shout php notices.
            $sub_mapping['language'] = $config['processor']['config']['language'];
            break;
          }
        }
      }

      if (isset($_sub_targets[$sub_target]['callback']) && function_exists($_sub_targets[$sub_target]['callback'])) {
        $callback = $_sub_targets[$sub_target]['callback'];

        // We have multiple values use them all.
        if (!is_array($v)) {
          $v = array($v);
        }

        // Check for a limit and force that limit.
        if ($info["cardinality"] !== "-1") {
          $v = array_slice($v, 0, $info["cardinality"]);
        }

        $callback($source, $field_collection_item, $sub_target, $v, $sub_mapping);
      }

      // No need to save the field collection here. Just wait until the node is saved.
      // If we save the FC here we get a huge performance degregation.
      $field['und'][$delta]['entity'] = $field_collection_item;

      // Break when only hitting the max delta.
      if ($delta > 0 && $info['cardinality'] == $delta) {
        break;
      }

      $delta++;
    }
  }
  catch (Exception $e) {
    drupal_set_message($e->getMessage(), 'error');
    watchdog_exception('field_collection', $e, $e->getMessage());
    throw $e;
  }

  $entity->{$target} = $field;
}

/**
 * Multiple field values are a pain in the rear. They are additive and we do not
 * always want them to be. This function targets a couple of items and truncates
 * their values before saving the new ones.
 * @param $target
 * @param $entity
 * @param $field
 * @param $field_collection_item
 * @param $value
 */
function stanford_feeds_helper_sub_target_pre_callback_parse($target, $sub_target, &$entity, &$field, &$field_collection_item, $value) {

  // Clear out all previous values as we want a replace and not an additive.
  // TODO: Add similar if block for other field collections.
  if ($target == "field_s_image_info") {
    switch ($sub_target) {
      case "field_s_image_image	":
      case "field_s_image_credits":
      case "field_s_image_source_info":
      case "field_s_image_caption":
        $field_collection_item->{$sub_target}[LANGUAGE_NONE] = array();
        break;
    }
  }

}
